plugins {
    id 'java'
    id 'org.springframework.boot' version '3.3.1'
    id 'io.spring.dependency-management' version '1.1.6'
    id 'jacoco-report-aggregation'
    id "org.sonarqube" version "6.0.1.5171"
}

sonar {
    properties {
        property "sonar.projectKey", "WooJJam_WooJJam-spring-lab_d7ee7d24-6c79-4eff-8790-e1f85826a992"
        property "sonar.projectName", "WooJJam-spring-lab"
    }
}

//sonarqube {
//    properties {
//        property "sonar.coverage.jacoco.xmlReportPaths", "**/build/reports/index.xml"
//    }
//}

import java.util.stream.Collectors

def excludeFromCoverage = new ArrayList<String>()
file('coverage-exclude.asap').withInputStream() { it ->
    excludeFromCoverage.addAll(new BufferedReader(new InputStreamReader(it))
            .lines()
            .parallel()
            .map(s -> s.substring(7).strip())
            .collect(Collectors.toList()))
}

group = 'co.kr.woojjam'
version = '0.0.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

repositories {
    mavenCentral()
}

bootJar { enabled = false }
jar { enabled = true }

allprojects {
    group = 'woojjam'
    version = '0.0.1-SNAPSHOT'

    apply plugin: 'java'
    apply plugin: 'java-library'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'io.spring.dependency-management'
    apply plugin: 'jacoco'
    apply plugin: 'jacoco-report-aggregation'

    configurations {
        compileOnly {
            extendsFrom annotationProcessor
        }
    }

    jacoco {
        toolVersion = "0.8.8"
    }

    repositories {
        mavenCentral()
    }

    jacocoTestReport {
        reports {
            html.required = true
            xml.required = true
            csv.required = true

            html.destination file("${buildDir}/reports/index.html")
            xml.destination file("${buildDir}/reports/index.xml")
            csv.destination file("${buildDir}/reports/index.csv")
        }

        afterEvaluate {
            classDirectories.setFrom(
                    files(classDirectories.files.collect {
                        fileTree(dir: it, excludes: excludeFromCoverage.stream()
                                .map(s -> s + ".class")
                                .collect(Collectors.toList()))
                    })
            )
        }

        finalizedBy 'jacocoTestCoverageVerification'
    }

    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
        implementation 'org.springframework.boot:spring-boot-starter-web'
        runtimeOnly 'com.mysql:mysql-connector-j'
        testImplementation 'org.springframework.boot:spring-boot-starter-test'
        testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

        compileOnly 'org.projectlombok:lombok'
        annotationProcessor 'org.projectlombok:lombok'
        testImplementation 'org.springframework.boot:spring-boot-starter-test'
        testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

        testCompileOnly 'org.projectlombok:lombok'
        testAnnotationProcessor 'org.projectlombok:lombok'
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = true
                element = "CLASS"
                limit {
                    counter = "LINE"
                    value = "COVEREDRATIO"
                    minimum = 0.0
                }
                excludes += excludeFromCoverage.stream()
                        .map(s -> s.replace("/", "."))
                        .collect(Collectors.toList())
            }
        }
    }

    test {
        useJUnitPlatform()
        jacoco {
            destinationFile = file("$buildDir/jacoco/jacoco.exec")
        }
        finalizedBy(jacocoTestReport)
    }
}

def allProjects = getAllprojects().stream()
        .filter(p -> !p.getDisplayName().contains('root project'))
        .collect(Collectors.toList())

project(':jacoco-test-reports') {
    apply plugin: 'jacoco-report-aggregation'

    testCodeCoverageReport {
        getClassDirectories().setFrom(files(allProjects
                .collect {
                    it.fileTree(dir: "${it.buildDir}/classes/java/main", exclude:
                            excludeFromCoverage.stream()
                                    .map(s -> s + ".class")
                                    .collect(Collectors.toList()))
                }
        ))
    }

    def allProjectsExcludeJacoco = allProjects.stream()
            .filter(p -> !p.getDisplayName().contains('jacoco')
                    && !p.getDisplayName().contains('root project'))
            .collect(Collectors.toList())

    dependencies {
        allProjectsExcludeJacoco.each { project ->
            implementation project
        }
    }
}
